// [참조 데이터 타입]

// @ 원시 데이터 타입 vs 참조 데이터 타입

// 원시 데이터 타입:
// 메모리 공간에 해당 변수를 위한 공간이 할당된다.
// 할당된 공간에 원시 타입의 값이 저장된다.
// 그러므로 원시 타입의 변수는 직접적으로 값을 가리킨다.
// 원시 타입의 변수는 하나의 값을 저장하기 때문에 가능하다.

// 참조 데이터 타입:
// 몇 개의 값이 저장될 지 모르기 때문에 힙(Heap)이라는 별도의 공간에 값을 저장한다.
// 참조 타입의 변수에는 Heap 메모리 주소값만 저장된다.
// 배열, 객체, 함수 등이 있다.

// [배열]: 데이터들의 집합
const arr = [1, 2, 3];
console.log(arr); // (3) [1, 2, 3]
console.log(arr[0]); // 1

// [객체]: 여러 타입을 가진 데이터들의 집합
// 각각의 요소가 키와 값으로 구성
// 형태는 {키: '값'}
// 프로퍼티: 키와 값의 쌍 ex) job: "개발자" 가 하나의 프로퍼티
const obj = {
    name: '허준혁',
    job: '개발자'
};
console.log(obj); // {name: '허준혁', job: '개발자'}

// @ 프로퍼티 접근
// .표기법
// 객체 이름 뒤에 .을 붙이고 접근하려는 프로퍼티의 키값을 지정
// 일반적인 상황에서는 .표기법을 사용한다.
console.log(obj.job); // 개발자
// 대괄호 표기법
// 객체 이름 뒤에 대괄호를 붙이고 접근하려는 프로퍼티의 키값을 문자열로 지정
console.log(obj['job']) // 개발자

// [배열과 객체의 공통점]

// @ 배열의 요소로 배열, 객체를 가질 수 있다.
const arr2 = [1, 2, 3, [4, 5]];
console.log(arr2); // (4) [1, 2, 3, Array(2)]
const arr3 = [1, 2, 3, {name: '허준혁', job: '개발자'}];
console.log(arr3); // (4) [1, 2, 3, {...}]

// @ 객체의 프로퍼티 값으로 배열, 객체를 가질 수 있다.
const obj2 = {
    arr: [1, 2, 3],
    obj: {
        name: '허준혁',
        job: '개발자'
    }
};
console.log(obj2); // {arr: Array(3), obj: {…}}